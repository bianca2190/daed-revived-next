{
  "actions": {
    "cancel": "Cancel",
    "confirm": "Confirm",
    "darkMode": "Dark",
    "edit": "Edit",
    "lightMode": "Light",
    "loading": "Loading {{resourceName}}...",
    "login": "Login",
    "logout": "Logout",
    "refresh": "Refresh",
    "remove": "Remove",
    "reset": "Reset",
    "select": "Select",
    "submit": "Submit",
    "switchLanguage": "Switch Language",
    "switchTheme": "Switch Theme",
    "systemMode": "System",
    "update": "Update {{resourceName}}"
  },
  "form": {
    "descriptions": {
      "allowInsecure": "Allow insecure TLS certificates. It is not recommended to turn it on unless you have to.",
      "autoConfigKernelParameter": "Automatically configure Linux kernel parameters like ip_forward and send_redirects",
      "checkTolerance": "Group will switch node only when new_latency <= (old_latency - tolerance)",
      "disableWaitingNetwork": "Disable waiting for network before pulling subscriptions",
      "group": {
        "Min": "Select the node with min last latency from the group for every connection",
        "MinAvg10": "Select the node with min average of the last 10 latencies from the group for every connection",
        "MinMovingAvg": "Select the node with min moving average of latencies from the group for every connection",
        "Random": "Randomly select a node from the group for every connection"
      },
      "lanInterface": "The LAN interface to bind. Use it if you want to proxy LAN",
      "pleaseEnter": "Please enter your {{fieldName}}",
      "pleaseSelect": "Please select your {{fieldName}}",
      "sniffingTimeout": "Timeout to waiting for first data sending for sniffing. It is always 0 if dial_mode is ip. Set it higher is useful in high latency LAN network",
      "soMarkFromDae": "If not zero, traffic sent from dae will be set SO_MARK. It is useful to avoid traffic loop with iptables/nftables tproxy rules",
      "tcpCheckHttpMethod": "The HTTP request method to TCP Check HTTP Method. Use HEAD by default because some server implementations bypass accounting for this kind of traffic",
      "tcpCheckUrl": "Host of URL should have both IPV4 and IPV6 if you have Dual Stack in local. First is URL, others are IP addresses if given. Considering traffic consumption, it is recommended to choose a site with Anycast IP and less response",
      "tlsImplementation": "TLS implementation. tls is to use GO's crypto/tls. utls is to use uTLS, which can imitate browser's Client Hello",
      "tproxyPort": "Transparent Proxy Port to listen on. Valid range is 0 - 65535. It is NOT a HTTP/SOCKS port, and is just used by eBPF program. In normal case, you do not need to use it",
      "tproxyPortProtect": "Set it true to protect tproxy port from unsolicited traffic. Set it false to allow users to use self-managed iptables tproxy rules",
      "udpCheckDns": "This DNS will be used to check UDP connectivity of nodes. And if dns_upstream below contains tcp, it also be used to check TCP DNS connectivity of nodes. First is URL, others are IP addresses if given. This DNS should have both IPV4 and IPV6 if you have Dual Stack in local",
      "utlsImitate": "The Client Hello ID for uTLS to imitate. This takes effect only if tls_implementation is utls",
      "wanInterface": "The WAN interface to bind. Use it if you want to proxy localhost"
    },
    "errors": {
      "passwordDontMatch": "密码不匹配"
    },
    "fields": {
      "allowInsecure": "Allow Insecure",
      "autoConfigKernelParameter": "Auto Config Kernel Parameter",
      "checkInterval": "Check Interval",
      "checkTolerance": "Check Tolerance",
      "confirmPassword": "Confirm Password",
      "currentPassword": "Current Password",
      "dialMode": "Dial Mode",
      "dialModes": {
        "domain": "Dial proxy using the domain from sniffing. This will relieve DNS pollution problem to a great extent if have impure DNS environment. Generally, this mode brings faster proxy response time because proxy will re-resolve the domain in remote, thus get better IP result to connect. This policy does not impact routing. That is to say, domain rewrite will be after traffic split of routing and dae will not re-route it.",
        "domain+": "Based on domain mode but do not check the reality of sniffed domain. It is useful for users whose DNS requests do not go through dae but want faster proxy response time. Notice that, if DNS requests do not go through dae, dae cannot split traffic by domain.",
        "domain++": "Based on domain+ mode but force to re-route traffic using sniffed domain to partially recover domain based traffic split ability. It doesn't work for direct traffic and consumes more CPU resources.",
        "ip": "Dial proxy using the IP from DNS directly. This allows your IPV4, IPV6 to choose the optimal path respectively, and makes the IP version requested by the application meet expectations. For example, if you use curl -4 ip.sb, you will request IPV4 via proxy and get a IPV4 echo. And curl -6 ip.sb will request IPV6. This may solve some weird full-cone problem if your are be your node support that. Sniffing will be disabled in this mode."
      },
      "disableWaitingNetwork": "Disable Waiting Network",
      "lanInterface": "LAN Interface",
      "link": "Link",
      "logLevel": "Log Level",
      "logLevels": {
        "debug": "debug",
        "error": "error",
        "info": "info",
        "trace": "trace",
        "warn": "warn"
      },
      "name": "Name",
      "newPassword": "New Password",
      "password": "Password",
      "sniffingTimeout": "Sniffing Timeout",
      "soMarkFromDae": "Set SO_MARK For dae",
      "tag": "Tag",
      "tcpCheckHttpMethod": "TCP Check HTTP Method",
      "tcpCheckUrl": "TCP Check URL",
      "tlsImplementation": "TLS Implementation",
      "tproxyPort": "Transparent Proxy Port",
      "tproxyPortProtect": "Transparent Proxy Port Protect",
      "udpCheckDns": "UDP Check DNS",
      "username": "Username",
      "utlsImitate": "uTLS Imitate",
      "wanInterface": "WAN Interface"
    }
  },
  "primitives": {
    "accountName": "Account Name: {{accountName}}",
    "accountSettings": "Account Settings",
    "action": "Action",
    "address": "Address",
    "autoDetect": "Auto Detect",
    "chineseSimplified": "Chinese Simplified",
    "config": "Config",
    "connectingOptions": "Connecting Options",
    "create": "Create {{resourceName}}",
    "default": "Default",
    "dns": "DNS",
    "endpointURL": "Endpoint URL",
    "english": "English",
    "general": "General",
    "group": "Group",
    "interfaceAndKernelOptions": "Interface and Kernel Options",
    "millisecond": "ms",
    "name": "Name",
    "network": "Network",
    "node": "Node",
    "nodeConnectivityCheck": "Node Connectivity Check",
    "policy": "Policy",
    "profile": "Profile",
    "protocol": "Protocol",
    "remove": "Remove {{resourceName}}",
    "routing": "Routing",
    "rule": "Rule",
    "second": "s",
    "settings": "Settings",
    "softwareOptions": "Software Options",
    "subscription": "Subscription",
    "tag": "Tag",
    "updatedAt": "Updated At",
    "username": "Username: {{username}}"
  }
}
